<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trigger Mode Data Save Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #2d3748;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .header-subtitle {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .header-controls {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary { background: #4299e1; color: white; }
        .btn-primary:hover { background: #3182ce; }
        
        .btn-warning { background: #ed8936; color: white; }
        .btn-warning:hover { background: #dd6b20; }
        
        .btn-success { background: #48bb78; color: white; }
        .btn-success:hover { background: #38a169; }
        
        .btn-danger { background: #f56565; color: white; }
        .btn-danger:hover { background: #e53e3e; }
        
        .btn-purple { background: #9f7aea; color: white; }
        .btn-purple:hover { background: #805ad5; }

        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: auto;
        }

        .status-connected { background: rgba(72, 187, 120, 0.2); color: #22543d; }
        .status-disconnected { background: rgba(245, 101, 101, 0.2); color: #742a2a; }
        .status-ready { background: rgba(237, 137, 54, 0.2); color: #7b341e; }

        .main-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 1.5rem;
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 1.5rem;
            min-height: calc(100vh - 120px);
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .right-panel {
            display: grid;
            grid-template-rows: 1fr auto;
            gap: 1.5rem;
        }

        .card {
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .card-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            background: #f7fafc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #2d3748;
        }

        .card-content {
            padding: 1.5rem;
        }

        .bursts-list {
            max-height: calc(100vh - 350px);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .burst-item {
            border: 2px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .burst-item:hover {
            border-color: #4299e1;
            background: #f7fafc;
        }

        .burst-item.selected {
            border-color: #4299e1;
            background: #ebf8ff;
        }

        .burst-item.complete::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #48bb78;
            border-radius: 0 0.25rem 0.25rem 0;
        }

        .burst-id {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .burst-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            font-size: 0.75rem;
            color: #718096;
        }

        .meta-item {
            display: flex;
            flex-direction: column;
        }

        .meta-value {
            font-weight: 600;
            color: #4a5568;
            font-size: 0.875rem;
        }

        .quality-badge {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 0.75rem;
            font-size: 0.625rem;
            font-weight: 600;
        }

        .quality-good { background: #c6f6d5; color: #22543d; }
        .quality-warning { background: #fbd38d; color: #7b341e; }
        .quality-error { background: #fed7d7; color: #742a2a; }

        .preview-content {
            min-height: 600px;
        }

        .stats-overview {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .stat-label {
            font-size: 0.75rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.25rem;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: #f7fafc;
            border-radius: 0.5rem;
        }

        .chart-container {
            height: 500px;
            position: relative;
            margin-bottom: 1rem;
        }

        .channel-stats {
            background: #f7fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            border-left: 4px solid #4299e1;
        }

        .bottom-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.5rem;
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            transition: border-color 0.2s;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn-save {
            width: 100%;
            padding: 0.875rem;
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn-save:hover:not(:disabled) {
            transform: translateY(-1px);
        }

        .btn-save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .files-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            font-size: 0.875rem;
            color: #374151;
        }

        .file-meta {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .btn-download {
            padding: 0.375rem 0.75rem;
            background: #4299e1;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #9ca3af;
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .loading {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 50%;
            border-top-color: #4299e1;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: #1f2937;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: translateX(120%);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 400px;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success { background: #48bb78; }
        .toast.error { background: #f56565; }
        .toast.warning { background: #ed8936; }
        .toast.info { background: #4299e1; }

        .connection-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            z-index: 999;
            transition: all 0.3s;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .bottom-section {
                grid-template-columns: 1fr;
            }

            .stats-overview {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="connection-indicator status-disconnected" id="connectionStatus">
        Disconnected
    </div>

    <div class="header">
        <h1>Trigger Mode Data Collection</h1>
        <div class="header-subtitle">Advanced trigger burst management and data analysis</div>
        
        <div class="header-controls">
            <button class="btn btn-primary" onclick="pingDevice()">
                <span id="pingIcon">Ping</span> Device
            </button>
            <button class="btn btn-warning" onclick="setTriggerMode()">
                Set Trigger Mode
            </button>
            <button class="btn btn-success" onclick="startCollection()">
                Start Collection
            </button>
            <button class="btn btn-danger" onclick="stopCollection()">
                Stop Collection
            </button>
            <button class="btn btn-purple" onclick="toggleExpandedView()">
                <span id="expandIcon">Expand</span> <span id="expandText">View</span>
            </button>
            
            <div class="status-badge status-disconnected" id="systemStatus">
                Device Disconnected
            </div>
        </div>
    </div>

    <div class="main-container" id="mainContainer">
        <div class="left-panel">
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Available Trigger Bursts</div>
                    <button class="btn btn-primary" onclick="refreshBursts()" style="padding: 0.375rem 0.75rem;">
                        <span id="refreshIcon">Refresh</span>
                    </button>
                </div>
                <div class="card-content">
                    <div class="bursts-list" id="burstsList">
                        <div class="empty-state">
                            <div class="empty-icon">üìä</div>
                            <div>No trigger bursts available</div>
                            <small>Start trigger mode collection to generate data</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="card">
                <div class="card-header">
                    <div class="card-title">Burst Analysis & Preview</div>
                </div>
                <div class="card-content">
                    <div class="preview-content" id="previewContent">
                        <div class="empty-state">
                            <div class="empty-icon">üëÅÔ∏è</div>
                            <div>Select a burst to analyze</div>
                            <small>Click on any burst from the list to view detailed analysis</small>
                        </div>
                    </div>
                </div>
            </div>

            <div class="bottom-section">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Save Configuration</div>
                    </div>
                    <div class="card-content">
                        <form id="saveForm">
                            <div class="form-group">
                                <label class="form-label">Directory Path</label>
                                <input type="text" class="form-input" id="saveDir" placeholder="data/experiments">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Filename</label>
                                <input type="text" class="form-input" id="saveFilename" placeholder="Auto-generated">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Format</label>
                                <select class="form-select" id="saveFormat">
                                    <option value="json">JSON (with metadata)</option>
                                    <option value="csv">CSV (for analysis)</option>
                                    <option value="binary">Binary (compact)</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Description</label>
                                <textarea class="form-textarea" id="saveDescription" placeholder="Optional description..."></textarea>
                            </div>
                            
                            <button type="submit" class="btn-save" id="saveBtn" disabled>
                                Save Selected Burst
                            </button>
                        </form>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Saved Files</div>
                        <button class="btn btn-primary" onclick="refreshFiles()" style="padding: 0.375rem 0.75rem;">
                            <span id="filesRefreshIcon">Refresh</span>
                        </button>
                    </div>
                    <div class="card-content">
                        <div class="files-list" id="filesList">
                            <div class="empty-state">
                                <div class="empty-icon">üìÑ</div>
                                <div>No saved files</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        // Configuration
        const API_BASE = 'http://127.0.0.1:8080/api';
        
        // State
        let bursts = [];
        let selectedBurstId = null;
        let chart = null;
        let echartsInstance = null;
        let files = [];
        let isExpandedView = false;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            setupEventListeners();
            loadSavedSettings();
        });

        async function initializeApp() {
            showConnectionStatus('connected');
            await getSystemStatus();
            await refreshBursts();
            await refreshFiles();
            setInterval(autoRefresh, 10000);
        }

        function setupEventListeners() {
            document.getElementById('saveForm').addEventListener('submit', handleSaveSubmit);
            
            ['saveDir', 'saveFormat', 'saveDescription'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveSettings);
                document.getElementById(id).addEventListener('input', saveSettings);
            });

            document.getElementById('saveFilename').addEventListener('focus', generateFilename);

            // Keyboard shortcuts
            document.addEventListener('keydown', function(event) {
                if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                    event.preventDefault();
                    if (selectedBurstId) {
                        document.getElementById('saveForm').dispatchEvent(new Event('submit'));
                    } else {
                        showToast('Select a burst first', 'warning');
                    }
                }
                
                if (event.key === 'F5') {
                    event.preventDefault();
                    refreshAll();
                }
            });
        }

        // Device control functions
        async function pingDevice() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<div class="loading"></div> Pinging...';
            btn.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE}/control/ping`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    showToast('Device ping successful', 'success');
                    await getSystemStatus();
                } else {
                    showToast(`Ping failed: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Ping error:', error);
                showToast('Failed to ping device', 'error');
                showConnectionStatus('disconnected');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function setTriggerMode() {
            try {
                const response = await fetch(`${API_BASE}/control/trigger_mode`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    showToast('Switched to trigger mode', 'success');
                    await getSystemStatus();
                } else {
                    showToast(`Failed to set trigger mode: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Set trigger mode error:', error);
                showToast('Failed to set trigger mode', 'error');
            }
        }

        async function startCollection() {
            try {
                const response = await fetch(`${API_BASE}/control/start`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    showToast('Data collection started', 'success');
                    await getSystemStatus();
                } else {
                    showToast(`Failed to start collection: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Start collection error:', error);
                showToast('Failed to start collection', 'error');
            }
        }

        async function stopCollection() {
            try {
                const response = await fetch(`${API_BASE}/control/stop`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    showToast('Data collection stopped', 'warning');
                    await getSystemStatus();
                } else {
                    showToast(`Failed to stop collection: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Stop collection error:', error);
                showToast('Failed to stop collection', 'error');
            }
        }

        async function getSystemStatus() {
            try {
                const response = await fetch(`${API_BASE}/control/status`);
                const data = await response.json();
                
                if (data.success) {
                    updateSystemStatus(data.data);
                    showConnectionStatus('connected');
                } else {
                    showConnectionStatus('disconnected');
                }
            } catch (error) {
                console.error('Get status error:', error);
                showConnectionStatus('disconnected');
            }
        }

        function updateSystemStatus(status) {
            const statusElement = document.getElementById('systemStatus');
            let statusText = 'Unknown';
            let statusClass = 'status-disconnected';
            
            if (status.device_connected && status.data_collection_active) {
                if (status.current_mode === 'trigger') {
                    statusText = 'Trigger Mode Active';
                    statusClass = 'status-connected';
                } else {
                    statusText = 'Collecting Data';
                    statusClass = 'status-connected';
                }
            } else if (status.device_connected && !status.data_collection_active) {
                statusText = status.current_mode === 'trigger' ? 'Trigger Mode Ready' : 'Device Ready';
                statusClass = 'status-ready';
            } else if (!status.device_connected) {
                statusText = 'Device Disconnected';
                statusClass = 'status-disconnected';
            }
            
            statusElement.textContent = statusText;
            statusElement.className = `status-badge ${statusClass}`;
        }

        async function refreshBursts() {
            const refreshIcon = document.getElementById('refreshIcon');
            const originalIcon = refreshIcon.textContent;
            refreshIcon.innerHTML = '<div class="loading"></div>';
            
            try {
                const response = await fetch(`${API_BASE}/trigger/list`);
                const data = await response.json();
                
                if (data.success) {
                    bursts = data.data || [];
                    renderBursts();
                    if (bursts.length > 0) {
                        showToast(`Loaded ${bursts.length} trigger bursts`, 'info');
                    }
                } else {
                    showToast('Failed to load trigger bursts', 'error');
                }
            } catch (error) {
                console.error('Refresh bursts error:', error);
                showToast('Connection error', 'error');
                showConnectionStatus('disconnected');
            } finally {
                refreshIcon.textContent = originalIcon;
            }
        }

        function renderBursts() {
            const container = document.getElementById('burstsList');
            
            if (bursts.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üìä</div>
                        <div>No trigger bursts available</div>
                        <small>Start trigger mode collection to generate data</small>
                    </div>
                `;
                return;
            }

            container.innerHTML = bursts.map(burst => `
                <div class="burst-item ${burst.can_save ? 'complete' : 'incomplete'}" 
                     data-burst-id="${burst.burst_id}"
                     onclick="selectBurst('${burst.burst_id}')">
                    <div class="quality-badge quality-${burst.quality.toLowerCase()}">
                        ${burst.quality}
                    </div>
                    <div class="burst-id">${burst.burst_id}</div>
                    <div class="burst-meta">
                        <div class="meta-item">
                            <div class="meta-value">${burst.total_samples}</div>
                            <div>Samples</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-value">Ch ${burst.trigger_channel}</div>
                            <div>Trigger</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-value">${burst.duration_ms.toFixed(1)}ms</div>
                            <div>Duration</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-value">${new Date(burst.created_at).toLocaleTimeString()}</div>
                            <div>Created</div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        async function selectBurst(burstId) {
            // Update selection
            document.querySelectorAll('.burst-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelector(`[data-burst-id="${burstId}"]`).classList.add('selected');
            
            selectedBurstId = burstId;
            document.getElementById('saveBtn').disabled = false;
            
            await loadBurstPreview(burstId);
            generateFilename();
        }

        async function loadBurstPreview(burstId) {
            try {
                const response = await fetch(`${API_BASE}/trigger/preview/${burstId}`);
                const data = await response.json();
                
                if (data.success) {
                    renderPreview(data.data);
                } else {
                    showToast('Failed to load burst preview', 'error');
                }
            } catch (error) {
                console.error('Preview error:', error);
                showToast('Failed to load preview', 'error');
            }
        }

        function renderPreview(burstData) {
            const container = document.getElementById('previewContent');
            
            const valueRange = burstData.quality_summary.value_range || [0, 0];
            const minValue = valueRange[0];
            const maxValue = valueRange[1];
            
            container.innerHTML = `
                <div class="stats-overview">
                    <div class="stat-card">
                        <div class="stat-value">${burstData.total_samples}</div>
                        <div class="stat-label">Total Samples</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${burstData.data_packets.length}</div>
                        <div class="stat-label">Data Packets</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${minValue.toFixed(2)}</div>
                        <div class="stat-label">Min Value</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${maxValue.toFixed(2)}</div>
                        <div class="stat-label">Max Value</div>
                    </div>
                </div>
                
                <div class="chart-controls">
                    <label>Chart Type:</label>
                    <select id="chartTypeSelector" onchange="updateChart(burstData)" class="form-select" style="width: auto;">
                        <option value="multi-channel">Multi-Channel View</option>
                        <option value="single-overview">Single Channel Overview</option>
                    </select>
                </div>
                
                <div class="chart-container">
                    <canvas id="previewChart" style="display: none;"></canvas>
                    <div id="echartsContainer" style="width: 100%; height: 100%;"></div>
                </div>
                
                <div class="channel-stats">
                    <strong>Channel Statistics:</strong>
                    ${burstData.quality_summary.channel_stats.map(stat => `
                        <div style="margin-top: 0.5rem; font-size: 0.875rem;">
                            <strong>CH${stat.channel_id}:</strong> 
                            Avg: ${stat.avg_value.toFixed(3)}, 
                            RMS: ${stat.rms_value.toFixed(3)}, 
                            Range: ${(stat.max_value - stat.min_value).toFixed(3)}
                        </div>
                    `).join('')}
                </div>
            `;

            createMultiChannelChart(burstData);
        }

        function updateChart(burstData) {
            const chartType = document.getElementById('chartTypeSelector').value;
            const canvasElement = document.getElementById('previewChart');
            const echartsElement = document.getElementById('echartsContainer');
            
            if (chartType === 'single-overview') {
                canvasElement.style.display = 'block';
                echartsElement.style.display = 'none';
                
                if (echartsInstance) {
                    echartsInstance.dispose();
                    echartsInstance = null;
                }
                
                createPreviewChart(burstData);
            } else {
                canvasElement.style.display = 'none';
                echartsElement.style.display = 'block';
                
                if (chart) {
                    chart.destroy();
                    chart = null;
                }
                
                createMultiChannelChart(burstData);
            }
        }

        function createMultiChannelChart(burstData) {
            if (echartsInstance) {
                echartsInstance.dispose();
            }

            const container = document.getElementById('echartsContainer');
            echartsInstance = echarts.init(container);

            const channelData = parseChannelData(burstData);
            
            if (channelData.channels.length === 0) {
                console.warn('No channel data available for chart');
                return;
            }

            const series = channelData.channels.map((channelId, index) => {
                const color = getChannelColor(index);
                return {
                    name: `Channel ${channelId}`,
                    type: 'line',
                    data: channelData.data[channelId] || [],
                    showSymbol: false,
                    lineStyle: { width: 2 },
                    itemStyle: { color: color }
                };
            });

            const option = {
                title: {
                    text: 'Multi-Channel Data Analysis',
                    left: 'center',
                    textStyle: { fontSize: 16, color: '#2d3748' }
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    formatter: function(params) {
                        let html = `<strong>Sample ${params[0].dataIndex}</strong><br/>`;
                        params.forEach(param => {
                            html += `${param.marker}${param.seriesName}: ${param.value.toFixed(4)}<br/>`;
                        });
                        return html;
                    }
                },
                legend: {
                    data: channelData.channels.map(id => `Channel ${id}`),
                    top: 30
                },
                grid: {
                    left: '5%',
                    right: '5%',
                    bottom: '15%',
                    top: '20%',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    boundaryGap: false,
                    name: 'Sample Index',
                    nameLocation: 'middle',
                    nameGap: 25,
                    data: channelData.sampleIndices
                },
                yAxis: {
                    type: 'value',
                    name: 'Value',
                    nameLocation: 'middle',
                    nameGap: 40,
                    scale: true
                },
                series: series,
                dataZoom: [
                    { type: 'inside', start: 0, end: 100 },
                    { type: 'slider', start: 0, end: 100, height: 30 }
                ]
            };

            echartsInstance.setOption(option);
            
            window.addEventListener('resize', () => {
                if (echartsInstance) {
                    echartsInstance.resize();
                }
            });
        }

        function parseChannelData(burstData) {
            const channelData = { channels: [], data: {}, sampleIndices: [] };
            
            if (!burstData.data_packets || burstData.data_packets.length === 0) {
                return channelData;
            }

            const channelIds = burstData.quality_summary.channel_stats.map(stat => stat.channel_id);
            channelData.channels = [...new Set(channelIds)].sort();

            channelData.channels.forEach(channelId => {
                channelData.data[channelId] = [];
            });

            for (const packet of burstData.data_packets) {
                const samplesPerChannel = Math.floor(packet.data.length / packet.channel_count);
                
                for (let chIdx = 0; chIdx < packet.channel_count; chIdx++) {
                    if (chIdx < channelData.channels.length) {
                        const channelId = channelData.channels[chIdx];
                        const startIdx = chIdx * samplesPerChannel;
                        const endIdx = startIdx + samplesPerChannel;
                        
                        if (endIdx <= packet.data.length) {
                            const channelSamples = packet.data.slice(startIdx, endIdx);
                            channelData.data[channelId].push(...channelSamples);
                        }
                    }
                }
            }

            const maxLength = Math.max(...Object.values(channelData.data).map(arr => arr.length));
            channelData.sampleIndices = Array.from({ length: Math.min(maxLength, 1000) }, (_, i) => i);
            
            channelData.channels.forEach(channelId => {
                if (channelData.data[channelId].length > 1000) {
                    channelData.data[channelId] = channelData.data[channelId].slice(0, 1000);
                }
            });

            return channelData;
        }

        function getChannelColor(index) {
            const colors = [
                '#667eea', '#48bb78', '#ed8936', '#f56565', 
                '#4299e1', '#9f7aea', '#38b2ac', '#d69e2e'
            ];
            return colors[index % colors.length];
        }

        function createPreviewChart(burstData) {
            const ctx = document.getElementById('previewChart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }

            const firstPacket = burstData.data_packets[0];
            const previewData = firstPacket ? firstPacket.data.slice(0, 200) : [];
            
            if (previewData.length === 0) {
                return;
            }
            
            const dataMin = Math.min(...previewData);
            const dataMax = Math.max(...previewData);
            const dataRange = dataMax - dataMin;
            const padding = dataRange > 0 ? dataRange * 0.1 : 1;
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: previewData.map((_, i) => i),
                    datasets: [{
                        label: 'Signal Data',
                        data: previewData,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.1,
                        pointRadius: 0,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: { display: false },
                        y: {
                            title: { display: true, text: 'Value' },
                            min: dataMin - padding,
                            max: dataMax + padding
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: 'Data Preview (First 200 Samples)' }
                    }
                }
            });
        }

        async function handleSaveSubmit(event) {
            event.preventDefault();
            
            if (!selectedBurstId) {
                showToast('Please select a burst to save', 'error');
                return;
            }

            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;

            try {
                const saveData = {
                    dir: document.getElementById('saveDir').value || null,
                    filename: document.getElementById('saveFilename').value || null,
                    format: document.getElementById('saveFormat').value,
                    description: document.getElementById('saveDescription').value || null
                };

                const response = await fetch(`${API_BASE}/trigger/save/${selectedBurstId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(saveData)
                });

                const result = await response.json();

                if (result.success) {
                    showToast(`Successfully saved: ${result.data.saved_path}`, 'success');
                    await refreshFiles();
                    
                    document.getElementById('saveFilename').value = '';
                    document.getElementById('saveDescription').value = '';
                } else {
                    showToast(`Save failed: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Save error:', error);
                showToast('Save operation failed', 'error');
            } finally {
                saveBtn.textContent = originalText;
                saveBtn.disabled = !selectedBurstId;
            }
        }

        async function refreshFiles() {
            const refreshIcon = document.getElementById('filesRefreshIcon');
            const originalIcon = refreshIcon.textContent;
            refreshIcon.innerHTML = '<div class="loading"></div>';
            
            try {
                const response = await fetch(`${API_BASE}/files`);
                const data = await response.json();
                
                if (data.success) {
                    files = data.data || [];
                    renderFiles();
                }
            } catch (error) {
                console.error('Refresh files error:', error);
            } finally {
                refreshIcon.textContent = originalIcon;
            }
        }

        function renderFiles() {
            const container = document.getElementById('filesList');
            
            if (files.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üìÑ</div>
                        <div>No saved files</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = files.map(file => `
                <div class="file-item">
                    <div class="file-info">
                        <div class="file-name">${file.filename}</div>
                        <div class="file-meta">
                            ${formatBytes(file.size_bytes)} ‚Ä¢ 
                            ${new Date(file.created_at).toLocaleString()} ‚Ä¢ 
                            ${file.file_type}
                        </div>
                    </div>
                    <button class="btn-download" onclick="downloadFile('${file.filename}')">
                        Download
                    </button>
                </div>
            `).join('');
        }

        async function downloadFile(filename) {
            try {
                const response = await fetch(`${API_BASE}/files/${encodeURIComponent(filename)}`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename.split('/').pop();
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    
                    showToast(`Downloaded: ${filename}`, 'success');
                } else {
                    showToast('Download failed', 'error');
                }
            } catch (error) {
                console.error('Download error:', error);
                showToast('Download failed', 'error');
            }
        }

        function generateFilename() {
            if (!selectedBurstId) return;
            
            const burst = bursts.find(b => b.burst_id === selectedBurstId);
            if (!burst) return;
            
            const filenameInput = document.getElementById('saveFilename');
            if (filenameInput.value.trim() === '') {
                const timestamp = new Date(burst.created_at).toISOString().slice(0, 19).replace(/:/g, '-');
                const triggerTs = burst.burst_id.includes('trigger_') ? 
                    burst.burst_id.split('_')[1] : burst.trigger_timestamp;
                
                filenameInput.value = `trigger_${triggerTs}_${timestamp}`;
            }
        }

        function toggleExpandedView() {
            isExpandedView = !isExpandedView;
            const container = document.getElementById('mainContainer');
            const expandText = document.getElementById('expandText');
            const expandIcon = document.getElementById('expandIcon');
            
            if (isExpandedView) {
                container.style.gridTemplateColumns = '500px 1fr';
                expandText.textContent = 'Compact';
                expandIcon.textContent = 'Shrink';
                showToast('Expanded to full view', 'info');
            } else {
                container.style.gridTemplateColumns = '400px 1fr';
                expandText.textContent = 'View';
                expandIcon.textContent = 'Expand';
                showToast('Returned to compact view', 'info');
            }
            
            if (echartsInstance) {
                setTimeout(() => echartsInstance.resize(), 300);
            }
            if (chart) {
                setTimeout(() => chart.resize(), 300);
            }
        }

        function saveSettings() {
            const settings = {
                saveDir: document.getElementById('saveDir').value,
                saveFormat: document.getElementById('saveFormat').value,
                saveDescription: document.getElementById('saveDescription').value
            };
            localStorage.setItem('triggerSaveSettings', JSON.stringify(settings));
        }

        function loadSavedSettings() {
            try {
                const settings = JSON.parse(localStorage.getItem('triggerSaveSettings') || '{}');
                if (settings.saveDir) document.getElementById('saveDir').value = settings.saveDir;
                if (settings.saveFormat) document.getElementById('saveFormat').value = settings.saveFormat;
                if (settings.saveDescription) document.getElementById('saveDescription').value = settings.saveDescription;
            } catch (e) {
                // Ignore errors
            }
        }

        async function autoRefresh() {
            try {
                await getSystemStatus();
                
                const response = await fetch(`${API_BASE}/trigger/list`);
                const data = await response.json();
                
                if (data.success) {
                    const newBurstCount = data.data.length;
                    const oldBurstCount = bursts.length;
                    
                    if (newBurstCount !== oldBurstCount) {
                        bursts = data.data || [];
                        renderBursts();
                        
                        if (newBurstCount > oldBurstCount) {
                            const newBursts = newBurstCount - oldBurstCount;
                            showToast(`${newBursts} new trigger burst${newBursts > 1 ? 's' : ''} detected!`, 'success');
                            
                            if (!selectedBurstId && bursts.length > 0) {
                                const newestBurst = bursts.sort((a, b) => b.created_at - a.created_at)[0];
                                if (newestBurst.can_save) {
                                    selectBurst(newestBurst.burst_id);
                                    showToast('Auto-selected newest complete burst', 'info');
                                }
                            }
                        }
                    }
                }
                
                showConnectionStatus('connected');
            } catch (error) {
                console.error('Auto refresh error:', error);
                showConnectionStatus('disconnected');
            }
        }

        async function refreshAll() {
            await Promise.all([getSystemStatus(), refreshBursts(), refreshFiles()]);
            showToast('All data refreshed', 'info');
        }

        function showConnectionStatus(status) {
            const indicator = document.getElementById('connectionStatus');
            indicator.className = `connection-indicator status-${status}`;
            indicator.textContent = status === 'connected' ? 'Connected' : 'Disconnected';
        }

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.className = `toast ${type} show`;
            toast.textContent = message;
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        console.log('Trigger Mode Data Collection initialized');
    </script>
</body>
</html>